\begin{frame}\frametitle{TCPSocketState}
\begin{itemize}
\item class to track socket state
    \begin{itemize}
    \item regarldess of congestion control algorithm
    \end{itemize}
\item includes (notably for us)
    \begin{itemize}
    \item `congesiton state'
    \item congestion window (cwnd)
    \item slow start threshold (ssthresh)
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{TCP congestion states}
\begin{itemize}
\item OPEN --- normal
\item DISORDER --- dupacks/SACKs below threshold for recovery
\item RECOVERY --- retransmitting due to dup-ACK/simple SACK
    \begin{itemize}
    \item temporarily inflated window to account for dropped packets
    \end{itemize}
\item LOSS --- retransmitting due to timeout/etc.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{configurable TCP behavior}
\begin{itemize}
\item TCPRecoveryOps: handle recovery
    \begin{itemize}
    \item EnterRecovery (called on start of retransmitting)
    \item default: cwnd $\rightarrow$ ssthresh
    \item DoRecovery (called for ACK when retransmitting)
    \item default: cwnd $\rightarrow$ cwnd + 1 packet
    \item ExitRecovery (called when `back to normal')
    \item default: cwnd $\rightarrow$ ssthresh
    \end{itemize}
\item \myemph{TCPCongestionOps}:
    \begin{itemize}
    \item IncreaseWindow (called when new segments ACKed)
    \item GetSsThresh (called after loss)
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}\frametitle{assingment TCP changes}
\begin{itemize}
\item will customize a \texttt{MyTcpCongestionOps}
\item \ldots which inherits from TCPNewReno
\vspace{.5cm}
\item you can customize increase (IncreaseWindow) and decrease (GetSsThresh)
\end{itemize}
\end{frame}

\begin{FragileFrame}
\frametitle{IncreaseWindow}
\begin{Verbatim}[fontsize=\fontsize{9}{10}]
void
TcpNewReno::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)
{
    NS_LOG_FUNCTION(this << tcb << segmentsAcked);
 
    if (tcb->m_cWnd < tcb->m_ssThresh)
    {
        segmentsAcked = SlowStart(tcb, segmentsAcked);
    }
 
    if (tcb->m_cWnd >= tcb->m_ssThresh)
    {
        CongestionAvoidance(tcb, segmentsAcked);
    }
}
\end{Verbatim}
\end{FragileFrame}

\begin{FragileFrame}
\frametitle{CongestionAvoidance}
\begin{Verbatim}[fontsize=\fontsize{9}{10}]
void
TcpNewReno::CongestionAvoidance(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)
{
    NS_LOG_FUNCTION(this << tcb << segmentsAcked);
 
    if (segmentsAcked > 0)
    {
        double adder =
            static_cast<double>(tcb->m_segmentSize * tcb->m_segmentSize) / tcb->m_cWnd.Get();
        adder = std::max(1.0, adder);
        tcb->m_cWnd += static_cast<uint32_t>(adder);
        ...
    }
}
\end{Verbatim}
\begin{itemize}
\item additive increase (plus 1 segment per cwnd)
\end{itemize}
\end{FragileFrame}

\begin{FragileFrame}
\frametitle{SlowStart}
\begin{Verbatim}[fontsize=\fontsize{9}{10}]
uint32_t
TcpNewReno::SlowStart(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)
{
    NS_LOG_FUNCTION(this << tcb << segmentsAcked);
 
    if (segmentsAcked >= 1)
    {
        tcb->m_cWnd += tcb->m_segmentSize;
        ...
        return segmentsAcked - 1;
    }
 
    return 0;
}
\end{Verbatim}
\begin{itemize}
\item multiplicative increase --- doubling
\end{itemize}
\end{FragileFrame}

\begin{FragileFrame}
\frametitle{GetSsThresh}
\begin{Verbatim}[fontsize=\fontsize{9}{10}]
uint32_t
TcpNewReno::GetSsThresh(Ptr<const TcpSocketState> state, uint32_t bytesInFlight)
{
    NS_LOG_FUNCTION(this << state << bytesInFlight);
 
    return std::max(2 * state->m_segmentSize, bytesInFlight / 2);
}
\end{Verbatim}
\begin{itemize}
\item multiplicative decrease (bytesInFlight / 2)
\end{itemize}
\end{FragileFrame}

\begin{frame}\frametitle{aside: more advanced congestion hooks}
\begin{itemize}
\item TcpCongestionOps also has access to
    \begin{itemize}
    \item ECN (explicit congestion notification) info
    \item timestamps
    \item exactly when duplicate ACKs below threshold/ recovery/etc. occurs
    \end{itemize}
\item used by more advanced TCP implementatoins
\end{itemize}
\end{frame}
